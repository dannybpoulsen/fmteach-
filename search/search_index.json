{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FMTeach++","text":"<p>Formal Methods in computer science is often taught to students with a focus on the theoretical aspects of formal methods i.e. the modelling formalisms, correctness of algorithms and so on.  Students are given practical experience through using tools that implements modelling formalisms and the algorithms. This is great for giving students practical experience in applying formal methods, but it fails to give students hands-on experience in implementing the formal methods that they been. </p> <p>This is highly unsatisfactory as many learn computer science/software students understands best by coding. FMTeach++ is a set of exercises that attempts to give students practical experience in implementing the algorithms they have been taught in the their course. </p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#building","title":"Building","text":"<p>Before getting started you need to compile FMTeach++. You need to recompile whenever you have solved an exercise</p> <pre><code>mkdir build\ncd build\ncmake ..\nmake\n</code></pre>"},{"location":"getting_started/#solving-exercises","title":"Solving Exercises","text":"<p>All exercises in FMTeach++ requires adding code to the repository. Exercises are solved by adding code to the <code>exercises/exer?/exer.cpp</code> files. It me beneficial to look around in the <code>lib</code> directory, but it should not be necessary to modify files here.   </p>"},{"location":"getting_started/#running-your-solution-to-an-exercise","title":"Running your solution to an exercise","text":"<p>After solving an exercise <code>exercisename</code> in the repository, you can use the  <code>fmteach</code> binary to run your solution on a program <code>program.whiley</code> </p> <pre><code>fmteach --i program.whiley --e exercisename\n</code></pre>"},{"location":"getting_started/#running-the-examplary-solution-to-an-exercise","title":"Running the examplary solution to an exercise","text":"<p>All exercises have a lecturer-implemented solution in the repository. To run the solution to <code>exercisename</code> on the the program <code>program.whiley</code>:</p> <pre><code>fmteach --s --i program.whiley --e exercisename\n</code></pre>"},{"location":"exercises/exercises/","title":"Exercises","text":""},{"location":"exercises/cfa/descr/","title":"Exercise 1","text":"<p>In this exercise we want to count the number of location in a CFA. You should implement your solution in the file <code>exercises/exer1/exer.cpp</code>. This is not particularly useful in general, but this task enables you to explore the repository. </p> <pre><code>#include \"ir/cfa.hpp\"\n#include \"exercises_plug.hpp\"\n#include \"setup.hpp\"\n#include &lt;cstdint&gt;\n\nnamespace FMTeach {\nnamespace Exer1 {\n\nFMTeach::Result_ptr FMTeach::Exer1::EnumStatesExer::student_solution (const FMTeach::IR::CFA&amp; /* (2) */ )  {\nthrow NotSolvedYet (__FILE__);    // (3)\nreturn std::make_unique&lt;FMTeach::Exer1::ResultExer&gt; (0); // (1)\n}\n}\n\n}\n\nnamespace {\nstatic FMTeach::Exer1::EnumStatesExer exer;\n}\n</code></pre> <ol> <li> You should change <code>0</code> to the number of locations your implmenentation found.</li> <li> Probably have a look at `libs/ir/include/cfa.hpp\" for the interface of the CFA class.</li> <li> Replace this <code>throw</code> with your solution </li> </ol>"},{"location":"exercises/cfa/descr/#tips","title":"Tips","text":"General IdeaSets in C++vector in C++ <p>Intuitively what you need is only to run through all locations and increment a counter everytime you encounter an unexplored one.   </p> <p>C++ have a type-parameterised implementation of sets in the class  <code>std::unordered_set</code>. You can use to keep all visited CFA-locations. Below are some examples of using the class.  </p> <pre><code>#include &lt;unordered_set&gt; //(4)\n\nFMTeach::Result_ptr FMTeach::Exer1::EnumStatesExer::student_solution (const FMTeach::IR::CFA&amp; cfa  )  {\nstd::unordered_set&lt;MiniMC::IR::Location_ptr&gt; passed; // (1)\npassed.insert (cfa.getInitial ()); // (2)\nif (passed.count (cfa.getInitial ()) ; // (3) \n\n}\n</code></pre> <ol> <li>Define a <code>std::unordered_set</code> storing <code>Location_ptr</code> </li> <li>Insert initial location of <code>cfa</code> into <code>passed</code> </li> <li>Check if the initial location is already  in <code>passed</code> </li> <li>Include header wit hthe definition of <code>std::unordered_set</code> </li> </ol> <p>You can use the type-parameterised <code>vector</code> -class of c++ as a waiting list. <pre><code>#include &lt;uvector&gt; //(4)\n\nFMTeach::Result_ptr FMTeach::Exer1::EnumStatesExer::student_solution (const FMTeach::IR::CFA&amp; cfa  )  {\nstd::vector&lt;MiniMC::IR::Location_ptr&gt; waiting; // (1)\nwaiting.push_back (cfa.getInitial ()); // (2)\nif (waiting.size () ; // (3) \n\nauto next = waiting.back (); // (5)\nwaiting-pop_back (); // (6)\n\n}\n</code></pre></p> <ol> <li>Define a <code>vector</code> storing <code>Location_ptr</code> </li> <li>Insert initial location of <code>cfa</code> into <code>waiting</code> </li> <li>Check if there is something in <code>waiting</code> </li> <li>Include header wit the definition of <code>std::vector</code> </li> <li>Get the last element of <code>waiting</code> </li> <li>Remove the last element from <code>waiting</code></li> </ol>"},{"location":"exercises/cfavis/descr/","title":"Exercise 2","text":""},{"location":"exercises/cfavis/descr/#exercise-2","title":"Exercise 2","text":"<p>In this exercise we wish to obtain  a graphical overview of the structure of the CFA. Your solution should be integrated into <code>exercises/exer2/exer.cpp</code></p> <pre><code>#include \"ir/cfa.hpp\"\n#include \"exercises_plug.hpp\"\n#include \"setup.hpp\"\n#include &lt;cstdint&gt;\n\nnamespace FMTeach {\nnamespace Exer2 {\n\nFMTeach::Result_ptr FMTeach::Exer2::CFAVisualiseExer::student_solution (const FMTeach::IR::CFA&amp;)  {\nGraph g; // (1)\nthrow NotSolvedYet (__FILE__);    // (2)\nreturn std::make_unique&lt;FMTeach::Exer2::ResultExer&gt; (std::move(g));\n}\n}\n\n}\n\nnamespace {\nstatic FMTeach::Exer2::CFAVisualiseExer exer;\n}\n</code></pre> <ol> <li>Graph structure you should add your solution to. You probably want to look at the file <code>exercises/exer2/setup.hpp</code> for the interface of the <code>Graph</code> class </li> <li>Replace this line with your solution</li> </ol>"},{"location":"exercises/cfavis/descr/#graph-structure","title":"Graph structure","text":"<p>To avoid you have to acquaint yourself with Graphviz (or similar graphing library), we provide a very simplified  <code>Graph g</code>  interface  to Grapviz.  In your code you can add an edge between <code>Location_ptr a</code> and <code>Location_ptr b</code> with label <code>std::string s</code> by calling <code>g.makeEdge (a,b,c)</code>.  </p>"},{"location":"exercises/interpreter/exer/","title":"Exercise 3","text":""},{"location":"exercises/interpreter/exer/#exercise-3","title":"Exercise 3","text":"<p>In this exercise the end goal is to have a concrete interpreter for Whiley --- that is we should be able to execute a (closed) program written in whiley.  Your implementation should be added to <code>exercises/exer3.cpp</code> <pre><code>#include \"ir/cfa.hpp\"\n#include \"exercises_plug.hpp\"\n#include \"setup.hpp\"\n#include &lt;cstdint&gt;\n\nnamespace FMTeach {\nnamespace Exer3 {\n\nFMTeach::Result_ptr FMTeach::Exer3::InterpreterExer::student_solution (const FMTeach::IR::CFA&amp; cfa)  {\nExecutionState state{cfa.getRegisters ().size (), 127, cfa.getInitial () }; // (1) \nthrow NotSolvedYet (__FILE__);    // (2)\nreturn std::make_unique&lt;FMTeach::Exer3::ResultExer&gt; (std::move(state)); }\n}\n\n}\n\nnamespace {\nstatic FMTeach::Exer3::InterpreterExer exer;\n}\n</code></pre></p> <ol> <li>The initial state of a Whiley program. You probably want to look at the file <code>exercises/exer3/setup.hpp</code> and <code>exercises/execstate/execstate.hpp\"</code> for how the state is represented </li> <li>Replace this line with your solution</li> </ol>"},{"location":"exercises/interpreter/exer/#visitors","title":"Visitors","text":"<p>To help you implement your interpreter both IR expressions and IR Instruction have a visitor pattern implemented. Look inside <code>libs/ir/include/instructions.hpp</code> and  <code>libs/ir/include/expr.hpp</code> to see their definitions.</p>"},{"location":"exercises/mc/exer/","title":"Exercise 4","text":""},{"location":"exercises/mc/exer/#exercise-4","title":"Exercise 4","text":"<p>In this exercise the end goal is to implement an Explicit State Reachability algorithm for Whiley.  Your implementation should be added to <code>exercises/exer4.cpp</code>, and you can probably big parts of your solution ot exercise 3. <pre><code>#include \"ir/cfa.hpp\"\n#include \"exercises_plug.hpp\"\n#include \"setup.hpp\"\n#include &lt;cstdint&gt;\n#include &lt;unordered_set&gt;\n\nnamespace FMTeach {\nnamespace Exer4 {\n\nFMTeach::Result_ptr FMTeach::Exer4::InitialisedExer::student_solution (const FMTeach::IR::CFA&amp; cfa)  {\nstd::vector&lt;ExecutionState&gt; violations;// (2)\nExecutionState state{cfa.getRegisters ().size (), 127, cfa.getInitial () }; // (1)\nthrow NotSolvedYet (__FILE__);\nreturn std::make_unique&lt;FMTeach::Exer4::ResultExer&gt; (std::move(violations));\n}\n}\n\n}\n\nnamespace {\nstatic FMTeach::Exer4::InitialisedExer exer;\n}\n</code></pre></p> <ol> <li>The initial state of a Whiley program. You probably want to look at the file <code>exercises/exer4/setup.hpp</code> and <code>exercises/execstate/execstate.hpp\"</code> for how the state is represented </li> <li>Vector of states you found violating an assert. You can check if a CFA location is an error state with <code>succ.getLocation ()-&gt;isAssert ()</code>. It will return <code>true</code> if the location an error location.</li> </ol>"}]}